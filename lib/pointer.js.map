{"version":3,"sources":["pointer.js"],"names":["get","set","remove","dict","walk","has","escape","unescape","parse","compile","obj","pointer","refTokens","Array","isArray","i","length","token","Error","value","tokens","nextToken","len","match","finalToken","slice","descend","results","toString","Object","prototype","iterator","type","call","next","cur","keys","key","push","pop","e","str","replace","charAt","substring","split","map","join"],"mappings":"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","file":"pointer.js","sourcesContent":["/**\n * @file json pointer utility tool\n * @author leon(ludafa@outlook.com)\n */\n\n/**\n * Lookup a json pointer in an object\n *\n * @param {Object} obj obj\n * @param {string|Array<string>} pointer pointer\n * @return {*}\n */\nexport function get(obj, pointer) {\n\n    const refTokens = Array.isArray(pointer) ? pointer : parse(pointer);\n\n    for (let i = 0; i < refTokens.length; ++i) {\n\n        const token = refTokens[i];\n\n        if (!(typeof obj === 'object' && token in obj)) {\n            throw new Error('Invalid reference token: ' + token);\n        }\n\n        obj = obj[token];\n\n    }\n\n    return obj;\n}\n\n/**\n * Sets a value on an object\n *\n * @param {Object} obj obj\n * @param {string|Array<string>} pointer pointer\n * @param {*} value value\n */\nexport function set(obj, pointer, value) {\n\n    if (pointer == null) {\n        return;\n    }\n\n    const tokens = Array.isArray(pointer) ? pointer : parse(pointer);\n    let nextToken = tokens[0];\n\n    for (let i = 0, len = tokens.length; i < len - 1; ++i) {\n\n        let token = tokens[i];\n\n        if (token === '-' && Array.isArray(obj)) {\n            token = obj.length;\n        }\n\n        nextToken = tokens[i + 1];\n\n        if (!(token in obj)) {\n\n            if (nextToken.match(/^(\\d+|-)$/)) {\n                obj[token] = [];\n            }\n            else {\n                obj[token] = {};\n            }\n\n        }\n\n        obj = obj[token];\n    }\n\n    if (nextToken === '-' && Array.isArray(obj)) {\n        nextToken = obj.length;\n    }\n\n    obj[nextToken] = value;\n\n}\n\n/**\n * Removes an attribute\n *\n * @param {Object} obj obj\n * @param {string|Array<string>} pointer pointer\n */\nexport function remove(obj, pointer) {\n\n    const refTokens = Array.isArray(pointer) ? pointer : parse(pointer);\n    const finalToken = refTokens[refTokens.length - 1];\n\n    if (finalToken === void 0) {\n        throw new Error('Invalid JSON pointer for remove: \"' + pointer + '\"');\n    }\n\n    delete get(obj, refTokens.slice(0, -1))[finalToken];\n}\n\n/**\n * Return a (pointer -> value) dictionary for an object\n *\n * @param {Object} obj obj\n * @param {Function} descend descend\n * @return {Object}\n */\nexport function dict(obj, descend) {\n    const results = {};\n    walk(obj, function (value, pointer) {\n        results[pointer] = value;\n    }, descend);\n    return results;\n}\n\nconst toString = Object.prototype.toString;\n\n/**\n * Iterates over an object\n * Iterator: function (value, pointer) {}\n *\n * @param {Object} obj obj\n * @param {Function} iterator iterator\n * @param {Function} descend descend\n */\nexport function walk(obj, iterator, descend) {\n\n    const tokens = [];\n\n    descend = descend || function (value) {\n        const type = toString.call(value).slice(8, -1);\n        return type === 'Object' || type === 'Array';\n    };\n\n    function next(cur) {\n        Object.keys(cur, function (key) {\n\n            const value = cur[key];\n\n            tokens.push(key);\n\n            if (descend(value)) {\n                next(value);\n            }\n            else {\n                iterator(value, compile(tokens));\n            }\n\n            tokens.pop();\n\n        });\n    }\n\n    next(obj);\n\n}\n\n/**\n * Tests if an object has a value for a json pointer\n *\n * @param {Object} obj     obj\n * @param {string} pointer pointer\n * @return {boolean}\n */\nexport function has(obj, pointer) {\n    try {\n        get(obj, pointer);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * Escapes a reference token\n *\n * @param {string} str str\n * @return {string}\n */\nexport function escape(str) {\n    return str.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n\n/**\n * Unescapes a reference token\n *\n * @param {string} str str\n * @return {string}\n */\nexport function unescape(str) {\n    return str.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n\n/**\n * Converts a json pointer into a array of reference tokens\n *\n * @param {string} pointer pointer\n * @return {Array}\n */\nexport function parse(pointer) {\n\n    if (!pointer) {\n        return [];\n    }\n\n    if (pointer.charAt(0) !== '/') {\n        throw new Error('Invalid JSON pointer: ' + pointer);\n    }\n\n    return pointer.substring(1).split(/\\//).map(unescape);\n}\n\n/**\n * Builds a json pointer from a array of reference tokens\n *\n * @param {Array<string>} refTokens tokens\n * @return {string}\n */\nexport function compile(refTokens) {\n    return !refTokens.length\n        ? '/' + refTokens.map(escape).join('/')\n        : '';\n}\n"],"sourceRoot":"/source/"}